#子程序管理方法及理论
**Note：**本文对子程序的分类及管理方法进行了阐述，为的是让读者了解到子程序管理的流程和理念，方便子程序的长期管理和维护。

##问题及背景
1. Lua函数可以随意重构
    
    从本质上说，子程序都是一个一个Lua函数。而Lua对于函数的重构具有惊人的包容性，只要函数名相同，后一个加载的函数就会将前一个函数覆盖。
    这样的机制对使用者提出了更高的要求，降低二次开发的适应性，滋生出了更多的风险。
2. 老平台中的子程序放置在一个文件中，难以维护。
    
    老平台受限于实现，将很多不相干的功能都放置在同一个文件中。这种方式带来的后果是：一错全错，查询繁琐……。
3. 不同行业中对于子程序的要求形式不同。
    
    在我们之前的概念中，子程序就是G代码的延伸，这是非常狭隘的。子程序应该是运动控制语言，G代码只是运动控制语言的一种封装而已。在数控行业
    子程序的形态可能是G代码，在其他行业有可能就是其他类型的代码。将G代码强制应用到不同的行业就是一种将我公司的实现强加到客户身上的行为，
    会极大影响到客户的体验。
##方法论
1. 尽量避免在全局表中添加子程序，多建立局部表。

    `_G`表是Lua默认的全局表，如果不加处理，所有定义的函数都会储存到`_G`表中去。当一个区域中的内容数量巨大并且不加区分的话，极其容易导致
    各种冲突和混乱。所以，除非是一些确实有必要的子程序，其他大多数子程序都不应该随意放置到全局表中去。对于一般的为某个功能而写的子程序可以
    利用局部表来承载。

2. 尽量避免将不是同一功能的子程序放置在一起。
    
    清晰地结构对于一次性的工作来说意义不大，但是子程序是需要长时间存在的，并且会由很多人不断推动他向前发展的。此时，清晰的结构能很好地告诉
    不同的维护者，应该在哪里做，不应该在哪里做。可以降低因为认识混乱造成的各种问题。

3. 运动指令的不同并不影响运动本身的实现。
    同一个运动本身，可能会有很多不同的运动指令。比如说`直线运动`。G代码中利用G01实现，自动化领域可能就是Mov指令。这种指令的不同其实都是对
    直线运动的封装而已。所以，我们要做的事情是将运动本身给定义清楚。而不是根据不同的实现去定义运动本身。

##第一步，分类子程序
![子程序分类](Resource\Image\子程序分类.jpg)

为了让每一个使用者都清晰地了解不同的子程序应该放置在哪里，子程序被分为了上图所示的三类：

1. 重构子程序

    由集成组件于其内部定义的，一定会带有Parser前缀的子程序为重构子程序。这部分子程序没有按功能分类，是因为他们的特殊性。
    要明确指出这些函数是重构的，风险极高的，不建议一般的二次开发人员进行处理的。并且这部分子程序的数量并不会特别多，所以一个文件可以承载地下。
    如果出现数量过多问题，可以考虑建立一个文件夹来进行管理。

2. 基本子程序

    即全局子程序，所有其他子程序中都能用到，具有广泛使用性的子程序称之为基本子程序。  

3. 功能子程序

    一般来说这些子程序都是为某一特定功能编写的，这种子程序里的一切都是为自己服务的。这种为特定功能编写的，具有局部意义的子程序称之为功能子程序。

##第二步，规定子程序的放置规则

1. 重构子程序放置的文件是唯一的，为`RestructuredFunction.lua`。所有的重构函数都要写在此文件中。

2. 基本子程序放置的文件是唯一的，为`GlobalFunctions.lua`。所有的全局函数都要写在此文件中。

3. 功能子程序放置的文件名需要具有该功能的语意，一个功能放置在单独的一个文件中，除非必要，不应该合并。

##第三步，通过映射满足指令形态变更。

我们在子程序加载的最后，建立了一张映射表。建立这张表的目的就是解决不同行业对运动指令的需求不同的问题。
比如我们直线运动的原指令为`Parser.MoveTo{}`,通过映射表，我们可以为数控行业设计出指令`G01{}`,也可以为自动化
行业设计出指令`Mov{}`.

